
cw5-Clock.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000aa6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000c  00800060  00000aa6  00000b3a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000043  0080006c  0080006c  00000b46  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000b46  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000000c0  00000000  00000000  00000b76  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000005cc  00000000  00000000  00000c36  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000347  00000000  00000000  00001202  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000003b0  00000000  00000000  00001549  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000278  00000000  00000000  000018fc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000332  00000000  00000000  00001b74  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000004eb  00000000  00000000  00001ea6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000090  00000000  00000000  00002391  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 95 02 	jmp	0x52a	; 0x52a <__vector_10>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e6 ea       	ldi	r30, 0xA6	; 166
  68:	fa e0       	ldi	r31, 0x0A	; 10
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	ac 36       	cpi	r26, 0x6C	; 108
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	20 e0       	ldi	r18, 0x00	; 0
  78:	ac e6       	ldi	r26, 0x6C	; 108
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	af 3a       	cpi	r26, 0xAF	; 175
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 17 03 	call	0x62e	; 0x62e <main>
  8a:	0c 94 51 05 	jmp	0xaa2	; 0xaa2 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <setupClockDisplay>:
volatile static uint8_t actual_display = 0;

void (*funToCallWhen1000)(void*) = 0;
void* argsToCallWhen1000 = 0;

void setupClockDisplay(){
  92:	cf 93       	push	r28
  94:	df 93       	push	r29
  96:	cd b7       	in	r28, 0x3d	; 61
  98:	de b7       	in	r29, 0x3e	; 62
	DISPLAY_DDR = 0xFF;
  9a:	8a e3       	ldi	r24, 0x3A	; 58
  9c:	90 e0       	ldi	r25, 0x00	; 0
  9e:	2f ef       	ldi	r18, 0xFF	; 255
  a0:	fc 01       	movw	r30, r24
  a2:	20 83       	st	Z, r18
	DISPLAY_PORT = 0x0;
  a4:	8b e3       	ldi	r24, 0x3B	; 59
  a6:	90 e0       	ldi	r25, 0x00	; 0
  a8:	fc 01       	movw	r30, r24
  aa:	10 82       	st	Z, r1
	DISPLAY_GRD_DDR = DISPLAY_GRD_DDR | 0x0F;
  ac:	87 e3       	ldi	r24, 0x37	; 55
  ae:	90 e0       	ldi	r25, 0x00	; 0
  b0:	27 e3       	ldi	r18, 0x37	; 55
  b2:	30 e0       	ldi	r19, 0x00	; 0
  b4:	f9 01       	movw	r30, r18
  b6:	20 81       	ld	r18, Z
  b8:	2f 60       	ori	r18, 0x0F	; 15
  ba:	fc 01       	movw	r30, r24
  bc:	20 83       	st	Z, r18
	DISPLAY_GRD_PORT = DISPLAY_GRD_PORT & 0xFF;
  be:	88 e3       	ldi	r24, 0x38	; 56
  c0:	90 e0       	ldi	r25, 0x00	; 0
  c2:	28 e3       	ldi	r18, 0x38	; 56
  c4:	30 e0       	ldi	r19, 0x00	; 0
  c6:	f9 01       	movw	r30, r18
  c8:	20 81       	ld	r18, Z
  ca:	fc 01       	movw	r30, r24
  cc:	20 83       	st	Z, r18
}
  ce:	df 91       	pop	r29
  d0:	cf 91       	pop	r28
  d2:	08 95       	ret

000000d4 <increment_value>:

void increment_value(void* args){
  d4:	cf 93       	push	r28
  d6:	df 93       	push	r29
  d8:	00 d0       	rcall	.+0      	; 0xda <increment_value+0x6>
  da:	cd b7       	in	r28, 0x3d	; 61
  dc:	de b7       	in	r29, 0x3e	; 62
  de:	9a 83       	std	Y+2, r25	; 0x02
  e0:	89 83       	std	Y+1, r24	; 0x01
	actual_time++;
  e2:	80 91 6c 00 	lds	r24, 0x006C
  e6:	90 91 6d 00 	lds	r25, 0x006D
  ea:	a0 91 6e 00 	lds	r26, 0x006E
  ee:	b0 91 6f 00 	lds	r27, 0x006F
  f2:	01 96       	adiw	r24, 0x01	; 1
  f4:	a1 1d       	adc	r26, r1
  f6:	b1 1d       	adc	r27, r1
  f8:	80 93 6c 00 	sts	0x006C, r24
  fc:	90 93 6d 00 	sts	0x006D, r25
 100:	a0 93 6e 00 	sts	0x006E, r26
 104:	b0 93 6f 00 	sts	0x006F, r27
}
 108:	0f 90       	pop	r0
 10a:	0f 90       	pop	r0
 10c:	df 91       	pop	r29
 10e:	cf 91       	pop	r28
 110:	08 95       	ret

00000112 <setupFunctionToCallWhen1000>:

void setupFunctionToCallWhen1000(void (*foo)(void*), void* args){
 112:	cf 93       	push	r28
 114:	df 93       	push	r29
 116:	00 d0       	rcall	.+0      	; 0x118 <setupFunctionToCallWhen1000+0x6>
 118:	00 d0       	rcall	.+0      	; 0x11a <setupFunctionToCallWhen1000+0x8>
 11a:	cd b7       	in	r28, 0x3d	; 61
 11c:	de b7       	in	r29, 0x3e	; 62
 11e:	9a 83       	std	Y+2, r25	; 0x02
 120:	89 83       	std	Y+1, r24	; 0x01
 122:	7c 83       	std	Y+4, r23	; 0x04
 124:	6b 83       	std	Y+3, r22	; 0x03
	funToCallWhen1000 = foo;
 126:	89 81       	ldd	r24, Y+1	; 0x01
 128:	9a 81       	ldd	r25, Y+2	; 0x02
 12a:	90 93 72 00 	sts	0x0072, r25
 12e:	80 93 71 00 	sts	0x0071, r24
	argsToCallWhen1000 = args;
 132:	8b 81       	ldd	r24, Y+3	; 0x03
 134:	9c 81       	ldd	r25, Y+4	; 0x04
 136:	90 93 74 00 	sts	0x0074, r25
 13a:	80 93 73 00 	sts	0x0073, r24
}
 13e:	0f 90       	pop	r0
 140:	0f 90       	pop	r0
 142:	0f 90       	pop	r0
 144:	0f 90       	pop	r0
 146:	df 91       	pop	r29
 148:	cf 91       	pop	r28
 14a:	08 95       	ret

0000014c <changeDisplayAbove1000sek>:

void changeDisplayAbove1000sek(void* args){
 14c:	0f 93       	push	r16
 14e:	1f 93       	push	r17
 150:	cf 93       	push	r28
 152:	df 93       	push	r29
 154:	cd b7       	in	r28, 0x3d	; 61
 156:	de b7       	in	r29, 0x3e	; 62
 158:	a2 97       	sbiw	r28, 0x22	; 34
 15a:	0f b6       	in	r0, 0x3f	; 63
 15c:	f8 94       	cli
 15e:	de bf       	out	0x3e, r29	; 62
 160:	0f be       	out	0x3f, r0	; 63
 162:	cd bf       	out	0x3d, r28	; 61
 164:	9a 83       	std	Y+2, r25	; 0x02
 166:	89 83       	std	Y+1, r24	; 0x01
	DISPLAY_GRD_PORT |= 0x0f;
 168:	88 e3       	ldi	r24, 0x38	; 56
 16a:	90 e0       	ldi	r25, 0x00	; 0
 16c:	28 e3       	ldi	r18, 0x38	; 56
 16e:	30 e0       	ldi	r19, 0x00	; 0
 170:	f9 01       	movw	r30, r18
 172:	20 81       	ld	r18, Z
 174:	2f 60       	ori	r18, 0x0F	; 15
 176:	fc 01       	movw	r30, r24
 178:	20 83       	st	Z, r18
	actual_display = (actual_display + 1) % 4;
 17a:	80 91 70 00 	lds	r24, 0x0070
 17e:	88 2f       	mov	r24, r24
 180:	90 e0       	ldi	r25, 0x00	; 0
 182:	01 96       	adiw	r24, 0x01	; 1
 184:	83 70       	andi	r24, 0x03	; 3
 186:	90 78       	andi	r25, 0x80	; 128
 188:	99 23       	and	r25, r25
 18a:	24 f4       	brge	.+8      	; 0x194 <changeDisplayAbove1000sek+0x48>
 18c:	01 97       	sbiw	r24, 0x01	; 1
 18e:	8c 6f       	ori	r24, 0xFC	; 252
 190:	9f 6f       	ori	r25, 0xFF	; 255
 192:	01 96       	adiw	r24, 0x01	; 1
 194:	80 93 70 00 	sts	0x0070, r24
	if (actual_display==0) DISPLAY_PORT = CYFRA[(actual_time/10)%10];
 198:	80 91 70 00 	lds	r24, 0x0070
 19c:	88 23       	and	r24, r24
 19e:	29 f5       	brne	.+74     	; 0x1ea <changeDisplayAbove1000sek+0x9e>
 1a0:	0b e3       	ldi	r16, 0x3B	; 59
 1a2:	10 e0       	ldi	r17, 0x00	; 0
 1a4:	80 91 6c 00 	lds	r24, 0x006C
 1a8:	90 91 6d 00 	lds	r25, 0x006D
 1ac:	a0 91 6e 00 	lds	r26, 0x006E
 1b0:	b0 91 6f 00 	lds	r27, 0x006F
 1b4:	2a e0       	ldi	r18, 0x0A	; 10
 1b6:	30 e0       	ldi	r19, 0x00	; 0
 1b8:	40 e0       	ldi	r20, 0x00	; 0
 1ba:	50 e0       	ldi	r21, 0x00	; 0
 1bc:	bc 01       	movw	r22, r24
 1be:	cd 01       	movw	r24, r26
 1c0:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__udivmodsi4>
 1c4:	da 01       	movw	r26, r20
 1c6:	c9 01       	movw	r24, r18
 1c8:	2a e0       	ldi	r18, 0x0A	; 10
 1ca:	30 e0       	ldi	r19, 0x00	; 0
 1cc:	40 e0       	ldi	r20, 0x00	; 0
 1ce:	50 e0       	ldi	r21, 0x00	; 0
 1d0:	bc 01       	movw	r22, r24
 1d2:	cd 01       	movw	r24, r26
 1d4:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__udivmodsi4>
 1d8:	dc 01       	movw	r26, r24
 1da:	cb 01       	movw	r24, r22
 1dc:	80 5a       	subi	r24, 0xA0	; 160
 1de:	9f 4f       	sbci	r25, 0xFF	; 255
 1e0:	fc 01       	movw	r30, r24
 1e2:	80 81       	ld	r24, Z
 1e4:	f8 01       	movw	r30, r16
 1e6:	80 83       	st	Z, r24
 1e8:	7a c0       	rjmp	.+244    	; 0x2de <changeDisplayAbove1000sek+0x192>
	else if (actual_display==1) DISPLAY_PORT = CYFRA[(actual_time/100)%10];
 1ea:	80 91 70 00 	lds	r24, 0x0070
 1ee:	81 30       	cpi	r24, 0x01	; 1
 1f0:	29 f5       	brne	.+74     	; 0x23c <changeDisplayAbove1000sek+0xf0>
 1f2:	0b e3       	ldi	r16, 0x3B	; 59
 1f4:	10 e0       	ldi	r17, 0x00	; 0
 1f6:	80 91 6c 00 	lds	r24, 0x006C
 1fa:	90 91 6d 00 	lds	r25, 0x006D
 1fe:	a0 91 6e 00 	lds	r26, 0x006E
 202:	b0 91 6f 00 	lds	r27, 0x006F
 206:	24 e6       	ldi	r18, 0x64	; 100
 208:	30 e0       	ldi	r19, 0x00	; 0
 20a:	40 e0       	ldi	r20, 0x00	; 0
 20c:	50 e0       	ldi	r21, 0x00	; 0
 20e:	bc 01       	movw	r22, r24
 210:	cd 01       	movw	r24, r26
 212:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__udivmodsi4>
 216:	da 01       	movw	r26, r20
 218:	c9 01       	movw	r24, r18
 21a:	2a e0       	ldi	r18, 0x0A	; 10
 21c:	30 e0       	ldi	r19, 0x00	; 0
 21e:	40 e0       	ldi	r20, 0x00	; 0
 220:	50 e0       	ldi	r21, 0x00	; 0
 222:	bc 01       	movw	r22, r24
 224:	cd 01       	movw	r24, r26
 226:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__udivmodsi4>
 22a:	dc 01       	movw	r26, r24
 22c:	cb 01       	movw	r24, r22
 22e:	80 5a       	subi	r24, 0xA0	; 160
 230:	9f 4f       	sbci	r25, 0xFF	; 255
 232:	fc 01       	movw	r30, r24
 234:	80 81       	ld	r24, Z
 236:	f8 01       	movw	r30, r16
 238:	80 83       	st	Z, r24
 23a:	51 c0       	rjmp	.+162    	; 0x2de <changeDisplayAbove1000sek+0x192>
	else if (actual_display==2) DISPLAY_PORT = CYFRA[(actual_time/1000)%10];
 23c:	80 91 70 00 	lds	r24, 0x0070
 240:	82 30       	cpi	r24, 0x02	; 2
 242:	29 f5       	brne	.+74     	; 0x28e <changeDisplayAbove1000sek+0x142>
 244:	0b e3       	ldi	r16, 0x3B	; 59
 246:	10 e0       	ldi	r17, 0x00	; 0
 248:	80 91 6c 00 	lds	r24, 0x006C
 24c:	90 91 6d 00 	lds	r25, 0x006D
 250:	a0 91 6e 00 	lds	r26, 0x006E
 254:	b0 91 6f 00 	lds	r27, 0x006F
 258:	28 ee       	ldi	r18, 0xE8	; 232
 25a:	33 e0       	ldi	r19, 0x03	; 3
 25c:	40 e0       	ldi	r20, 0x00	; 0
 25e:	50 e0       	ldi	r21, 0x00	; 0
 260:	bc 01       	movw	r22, r24
 262:	cd 01       	movw	r24, r26
 264:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__udivmodsi4>
 268:	da 01       	movw	r26, r20
 26a:	c9 01       	movw	r24, r18
 26c:	2a e0       	ldi	r18, 0x0A	; 10
 26e:	30 e0       	ldi	r19, 0x00	; 0
 270:	40 e0       	ldi	r20, 0x00	; 0
 272:	50 e0       	ldi	r21, 0x00	; 0
 274:	bc 01       	movw	r22, r24
 276:	cd 01       	movw	r24, r26
 278:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__udivmodsi4>
 27c:	dc 01       	movw	r26, r24
 27e:	cb 01       	movw	r24, r22
 280:	80 5a       	subi	r24, 0xA0	; 160
 282:	9f 4f       	sbci	r25, 0xFF	; 255
 284:	fc 01       	movw	r30, r24
 286:	80 81       	ld	r24, Z
 288:	f8 01       	movw	r30, r16
 28a:	80 83       	st	Z, r24
 28c:	28 c0       	rjmp	.+80     	; 0x2de <changeDisplayAbove1000sek+0x192>
	else if (actual_display==3) DISPLAY_PORT = CYFRA[(actual_time/10000)%10];
 28e:	80 91 70 00 	lds	r24, 0x0070
 292:	83 30       	cpi	r24, 0x03	; 3
 294:	21 f5       	brne	.+72     	; 0x2de <changeDisplayAbove1000sek+0x192>
 296:	0b e3       	ldi	r16, 0x3B	; 59
 298:	10 e0       	ldi	r17, 0x00	; 0
 29a:	80 91 6c 00 	lds	r24, 0x006C
 29e:	90 91 6d 00 	lds	r25, 0x006D
 2a2:	a0 91 6e 00 	lds	r26, 0x006E
 2a6:	b0 91 6f 00 	lds	r27, 0x006F
 2aa:	20 e1       	ldi	r18, 0x10	; 16
 2ac:	37 e2       	ldi	r19, 0x27	; 39
 2ae:	40 e0       	ldi	r20, 0x00	; 0
 2b0:	50 e0       	ldi	r21, 0x00	; 0
 2b2:	bc 01       	movw	r22, r24
 2b4:	cd 01       	movw	r24, r26
 2b6:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__udivmodsi4>
 2ba:	da 01       	movw	r26, r20
 2bc:	c9 01       	movw	r24, r18
 2be:	2a e0       	ldi	r18, 0x0A	; 10
 2c0:	30 e0       	ldi	r19, 0x00	; 0
 2c2:	40 e0       	ldi	r20, 0x00	; 0
 2c4:	50 e0       	ldi	r21, 0x00	; 0
 2c6:	bc 01       	movw	r22, r24
 2c8:	cd 01       	movw	r24, r26
 2ca:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__udivmodsi4>
 2ce:	dc 01       	movw	r26, r24
 2d0:	cb 01       	movw	r24, r22
 2d2:	80 5a       	subi	r24, 0xA0	; 160
 2d4:	9f 4f       	sbci	r25, 0xFF	; 255
 2d6:	fc 01       	movw	r30, r24
 2d8:	80 81       	ld	r24, Z
 2da:	f8 01       	movw	r30, r16
 2dc:	80 83       	st	Z, r24
	DISPLAY_GRD_PORT &= (0xF0 | (~(1<<actual_display)));
 2de:	88 e3       	ldi	r24, 0x38	; 56
 2e0:	90 e0       	ldi	r25, 0x00	; 0
 2e2:	28 e3       	ldi	r18, 0x38	; 56
 2e4:	30 e0       	ldi	r19, 0x00	; 0
 2e6:	f9 01       	movw	r30, r18
 2e8:	20 81       	ld	r18, Z
 2ea:	62 2f       	mov	r22, r18
 2ec:	20 91 70 00 	lds	r18, 0x0070
 2f0:	42 2f       	mov	r20, r18
 2f2:	50 e0       	ldi	r21, 0x00	; 0
 2f4:	21 e0       	ldi	r18, 0x01	; 1
 2f6:	30 e0       	ldi	r19, 0x00	; 0
 2f8:	04 2e       	mov	r0, r20
 2fa:	02 c0       	rjmp	.+4      	; 0x300 <changeDisplayAbove1000sek+0x1b4>
 2fc:	22 0f       	add	r18, r18
 2fe:	33 1f       	adc	r19, r19
 300:	0a 94       	dec	r0
 302:	e2 f7       	brpl	.-8      	; 0x2fc <changeDisplayAbove1000sek+0x1b0>
 304:	20 95       	com	r18
 306:	20 6f       	ori	r18, 0xF0	; 240
 308:	26 23       	and	r18, r22
 30a:	fc 01       	movw	r30, r24
 30c:	20 83       	st	Z, r18
}
 30e:	a2 96       	adiw	r28, 0x22	; 34
 310:	0f b6       	in	r0, 0x3f	; 63
 312:	f8 94       	cli
 314:	de bf       	out	0x3e, r29	; 62
 316:	0f be       	out	0x3f, r0	; 63
 318:	cd bf       	out	0x3d, r28	; 61
 31a:	df 91       	pop	r29
 31c:	cf 91       	pop	r28
 31e:	1f 91       	pop	r17
 320:	0f 91       	pop	r16
 322:	08 95       	ret

00000324 <changeDisplayUnder1000sek>:

void changeDisplayUnder1000sek(void* args){
 324:	0f 93       	push	r16
 326:	1f 93       	push	r17
 328:	cf 93       	push	r28
 32a:	df 93       	push	r29
 32c:	cd b7       	in	r28, 0x3d	; 61
 32e:	de b7       	in	r29, 0x3e	; 62
 330:	6e 97       	sbiw	r28, 0x1e	; 30
 332:	0f b6       	in	r0, 0x3f	; 63
 334:	f8 94       	cli
 336:	de bf       	out	0x3e, r29	; 62
 338:	0f be       	out	0x3f, r0	; 63
 33a:	cd bf       	out	0x3d, r28	; 61
 33c:	9a 83       	std	Y+2, r25	; 0x02
 33e:	89 83       	std	Y+1, r24	; 0x01
	DISPLAY_GRD_PORT |= 0x0f;
 340:	88 e3       	ldi	r24, 0x38	; 56
 342:	90 e0       	ldi	r25, 0x00	; 0
 344:	28 e3       	ldi	r18, 0x38	; 56
 346:	30 e0       	ldi	r19, 0x00	; 0
 348:	f9 01       	movw	r30, r18
 34a:	20 81       	ld	r18, Z
 34c:	2f 60       	ori	r18, 0x0F	; 15
 34e:	fc 01       	movw	r30, r24
 350:	20 83       	st	Z, r18
	actual_display = (actual_display + 1) % 4;
 352:	80 91 70 00 	lds	r24, 0x0070
 356:	88 2f       	mov	r24, r24
 358:	90 e0       	ldi	r25, 0x00	; 0
 35a:	01 96       	adiw	r24, 0x01	; 1
 35c:	83 70       	andi	r24, 0x03	; 3
 35e:	90 78       	andi	r25, 0x80	; 128
 360:	99 23       	and	r25, r25
 362:	24 f4       	brge	.+8      	; 0x36c <changeDisplayUnder1000sek+0x48>
 364:	01 97       	sbiw	r24, 0x01	; 1
 366:	8c 6f       	ori	r24, 0xFC	; 252
 368:	9f 6f       	ori	r25, 0xFF	; 255
 36a:	01 96       	adiw	r24, 0x01	; 1
 36c:	80 93 70 00 	sts	0x0070, r24
	if (actual_display==0) DISPLAY_PORT = CYFRA[actual_time%10];
 370:	80 91 70 00 	lds	r24, 0x0070
 374:	88 23       	and	r24, r24
 376:	d9 f4       	brne	.+54     	; 0x3ae <changeDisplayUnder1000sek+0x8a>
 378:	0b e3       	ldi	r16, 0x3B	; 59
 37a:	10 e0       	ldi	r17, 0x00	; 0
 37c:	80 91 6c 00 	lds	r24, 0x006C
 380:	90 91 6d 00 	lds	r25, 0x006D
 384:	a0 91 6e 00 	lds	r26, 0x006E
 388:	b0 91 6f 00 	lds	r27, 0x006F
 38c:	2a e0       	ldi	r18, 0x0A	; 10
 38e:	30 e0       	ldi	r19, 0x00	; 0
 390:	40 e0       	ldi	r20, 0x00	; 0
 392:	50 e0       	ldi	r21, 0x00	; 0
 394:	bc 01       	movw	r22, r24
 396:	cd 01       	movw	r24, r26
 398:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__udivmodsi4>
 39c:	dc 01       	movw	r26, r24
 39e:	cb 01       	movw	r24, r22
 3a0:	80 5a       	subi	r24, 0xA0	; 160
 3a2:	9f 4f       	sbci	r25, 0xFF	; 255
 3a4:	fc 01       	movw	r30, r24
 3a6:	80 81       	ld	r24, Z
 3a8:	f8 01       	movw	r30, r16
 3aa:	80 83       	st	Z, r24
 3ac:	7d c0       	rjmp	.+250    	; 0x4a8 <changeDisplayUnder1000sek+0x184>
	else if (actual_display==1) { DISPLAY_PORT = CYFRA[(actual_time/10)%10] & DOT ; }
 3ae:	80 91 70 00 	lds	r24, 0x0070
 3b2:	81 30       	cpi	r24, 0x01	; 1
 3b4:	41 f5       	brne	.+80     	; 0x406 <changeDisplayUnder1000sek+0xe2>
 3b6:	0b e3       	ldi	r16, 0x3B	; 59
 3b8:	10 e0       	ldi	r17, 0x00	; 0
 3ba:	80 91 6c 00 	lds	r24, 0x006C
 3be:	90 91 6d 00 	lds	r25, 0x006D
 3c2:	a0 91 6e 00 	lds	r26, 0x006E
 3c6:	b0 91 6f 00 	lds	r27, 0x006F
 3ca:	2a e0       	ldi	r18, 0x0A	; 10
 3cc:	30 e0       	ldi	r19, 0x00	; 0
 3ce:	40 e0       	ldi	r20, 0x00	; 0
 3d0:	50 e0       	ldi	r21, 0x00	; 0
 3d2:	bc 01       	movw	r22, r24
 3d4:	cd 01       	movw	r24, r26
 3d6:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__udivmodsi4>
 3da:	da 01       	movw	r26, r20
 3dc:	c9 01       	movw	r24, r18
 3de:	2a e0       	ldi	r18, 0x0A	; 10
 3e0:	30 e0       	ldi	r19, 0x00	; 0
 3e2:	40 e0       	ldi	r20, 0x00	; 0
 3e4:	50 e0       	ldi	r21, 0x00	; 0
 3e6:	bc 01       	movw	r22, r24
 3e8:	cd 01       	movw	r24, r26
 3ea:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__udivmodsi4>
 3ee:	dc 01       	movw	r26, r24
 3f0:	cb 01       	movw	r24, r22
 3f2:	80 5a       	subi	r24, 0xA0	; 160
 3f4:	9f 4f       	sbci	r25, 0xFF	; 255
 3f6:	fc 01       	movw	r30, r24
 3f8:	90 81       	ld	r25, Z
 3fa:	80 91 6a 00 	lds	r24, 0x006A
 3fe:	89 23       	and	r24, r25
 400:	f8 01       	movw	r30, r16
 402:	80 83       	st	Z, r24
 404:	51 c0       	rjmp	.+162    	; 0x4a8 <changeDisplayUnder1000sek+0x184>
	else if (actual_display==2) DISPLAY_PORT = CYFRA[(actual_time/100)%10];
 406:	80 91 70 00 	lds	r24, 0x0070
 40a:	82 30       	cpi	r24, 0x02	; 2
 40c:	29 f5       	brne	.+74     	; 0x458 <changeDisplayUnder1000sek+0x134>
 40e:	0b e3       	ldi	r16, 0x3B	; 59
 410:	10 e0       	ldi	r17, 0x00	; 0
 412:	80 91 6c 00 	lds	r24, 0x006C
 416:	90 91 6d 00 	lds	r25, 0x006D
 41a:	a0 91 6e 00 	lds	r26, 0x006E
 41e:	b0 91 6f 00 	lds	r27, 0x006F
 422:	24 e6       	ldi	r18, 0x64	; 100
 424:	30 e0       	ldi	r19, 0x00	; 0
 426:	40 e0       	ldi	r20, 0x00	; 0
 428:	50 e0       	ldi	r21, 0x00	; 0
 42a:	bc 01       	movw	r22, r24
 42c:	cd 01       	movw	r24, r26
 42e:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__udivmodsi4>
 432:	da 01       	movw	r26, r20
 434:	c9 01       	movw	r24, r18
 436:	2a e0       	ldi	r18, 0x0A	; 10
 438:	30 e0       	ldi	r19, 0x00	; 0
 43a:	40 e0       	ldi	r20, 0x00	; 0
 43c:	50 e0       	ldi	r21, 0x00	; 0
 43e:	bc 01       	movw	r22, r24
 440:	cd 01       	movw	r24, r26
 442:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__udivmodsi4>
 446:	dc 01       	movw	r26, r24
 448:	cb 01       	movw	r24, r22
 44a:	80 5a       	subi	r24, 0xA0	; 160
 44c:	9f 4f       	sbci	r25, 0xFF	; 255
 44e:	fc 01       	movw	r30, r24
 450:	80 81       	ld	r24, Z
 452:	f8 01       	movw	r30, r16
 454:	80 83       	st	Z, r24
 456:	28 c0       	rjmp	.+80     	; 0x4a8 <changeDisplayUnder1000sek+0x184>
	else if (actual_display==3) DISPLAY_PORT = CYFRA[(actual_time/1000)%10];
 458:	80 91 70 00 	lds	r24, 0x0070
 45c:	83 30       	cpi	r24, 0x03	; 3
 45e:	21 f5       	brne	.+72     	; 0x4a8 <changeDisplayUnder1000sek+0x184>
 460:	0b e3       	ldi	r16, 0x3B	; 59
 462:	10 e0       	ldi	r17, 0x00	; 0
 464:	80 91 6c 00 	lds	r24, 0x006C
 468:	90 91 6d 00 	lds	r25, 0x006D
 46c:	a0 91 6e 00 	lds	r26, 0x006E
 470:	b0 91 6f 00 	lds	r27, 0x006F
 474:	28 ee       	ldi	r18, 0xE8	; 232
 476:	33 e0       	ldi	r19, 0x03	; 3
 478:	40 e0       	ldi	r20, 0x00	; 0
 47a:	50 e0       	ldi	r21, 0x00	; 0
 47c:	bc 01       	movw	r22, r24
 47e:	cd 01       	movw	r24, r26
 480:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__udivmodsi4>
 484:	da 01       	movw	r26, r20
 486:	c9 01       	movw	r24, r18
 488:	2a e0       	ldi	r18, 0x0A	; 10
 48a:	30 e0       	ldi	r19, 0x00	; 0
 48c:	40 e0       	ldi	r20, 0x00	; 0
 48e:	50 e0       	ldi	r21, 0x00	; 0
 490:	bc 01       	movw	r22, r24
 492:	cd 01       	movw	r24, r26
 494:	0e 94 2f 05 	call	0xa5e	; 0xa5e <__udivmodsi4>
 498:	dc 01       	movw	r26, r24
 49a:	cb 01       	movw	r24, r22
 49c:	80 5a       	subi	r24, 0xA0	; 160
 49e:	9f 4f       	sbci	r25, 0xFF	; 255
 4a0:	fc 01       	movw	r30, r24
 4a2:	80 81       	ld	r24, Z
 4a4:	f8 01       	movw	r30, r16
 4a6:	80 83       	st	Z, r24
	DISPLAY_GRD_PORT &= (0xF0 | (~(1<<actual_display)));
 4a8:	88 e3       	ldi	r24, 0x38	; 56
 4aa:	90 e0       	ldi	r25, 0x00	; 0
 4ac:	28 e3       	ldi	r18, 0x38	; 56
 4ae:	30 e0       	ldi	r19, 0x00	; 0
 4b0:	f9 01       	movw	r30, r18
 4b2:	20 81       	ld	r18, Z
 4b4:	62 2f       	mov	r22, r18
 4b6:	20 91 70 00 	lds	r18, 0x0070
 4ba:	42 2f       	mov	r20, r18
 4bc:	50 e0       	ldi	r21, 0x00	; 0
 4be:	21 e0       	ldi	r18, 0x01	; 1
 4c0:	30 e0       	ldi	r19, 0x00	; 0
 4c2:	04 2e       	mov	r0, r20
 4c4:	02 c0       	rjmp	.+4      	; 0x4ca <changeDisplayUnder1000sek+0x1a6>
 4c6:	22 0f       	add	r18, r18
 4c8:	33 1f       	adc	r19, r19
 4ca:	0a 94       	dec	r0
 4cc:	e2 f7       	brpl	.-8      	; 0x4c6 <changeDisplayUnder1000sek+0x1a2>
 4ce:	20 95       	com	r18
 4d0:	20 6f       	ori	r18, 0xF0	; 240
 4d2:	26 23       	and	r18, r22
 4d4:	fc 01       	movw	r30, r24
 4d6:	20 83       	st	Z, r18
	
	if (actual_time >= 1000 && funToCallWhen1000!=0) funToCallWhen1000(argsToCallWhen1000);
 4d8:	80 91 6c 00 	lds	r24, 0x006C
 4dc:	90 91 6d 00 	lds	r25, 0x006D
 4e0:	a0 91 6e 00 	lds	r26, 0x006E
 4e4:	b0 91 6f 00 	lds	r27, 0x006F
 4e8:	88 3e       	cpi	r24, 0xE8	; 232
 4ea:	f3 e0       	ldi	r31, 0x03	; 3
 4ec:	9f 07       	cpc	r25, r31
 4ee:	a1 05       	cpc	r26, r1
 4f0:	b1 05       	cpc	r27, r1
 4f2:	80 f0       	brcs	.+32     	; 0x514 <changeDisplayUnder1000sek+0x1f0>
 4f4:	80 91 71 00 	lds	r24, 0x0071
 4f8:	90 91 72 00 	lds	r25, 0x0072
 4fc:	00 97       	sbiw	r24, 0x00	; 0
 4fe:	51 f0       	breq	.+20     	; 0x514 <changeDisplayUnder1000sek+0x1f0>
 500:	20 91 71 00 	lds	r18, 0x0071
 504:	30 91 72 00 	lds	r19, 0x0072
 508:	80 91 73 00 	lds	r24, 0x0073
 50c:	90 91 74 00 	lds	r25, 0x0074
 510:	f9 01       	movw	r30, r18
 512:	09 95       	icall
	//changeThisTask(change_display_above_1000_sek, (void*)0);
 514:	6e 96       	adiw	r28, 0x1e	; 30
 516:	0f b6       	in	r0, 0x3f	; 63
 518:	f8 94       	cli
 51a:	de bf       	out	0x3e, r29	; 62
 51c:	0f be       	out	0x3f, r0	; 63
 51e:	cd bf       	out	0x3d, r28	; 61
 520:	df 91       	pop	r29
 522:	cf 91       	pop	r28
 524:	1f 91       	pop	r17
 526:	0f 91       	pop	r16
 528:	08 95       	ret

0000052a <__vector_10>:

#include <avr/io.h>
#include "taskManager.h"
#include "clockDisplay.h"

ISR(TIMER0_COMP_vect){
 52a:	1f 92       	push	r1
 52c:	0f 92       	push	r0
 52e:	00 90 5f 00 	lds	r0, 0x005F
 532:	0f 92       	push	r0
 534:	11 24       	eor	r1, r1
 536:	2f 93       	push	r18
 538:	3f 93       	push	r19
 53a:	4f 93       	push	r20
 53c:	5f 93       	push	r21
 53e:	6f 93       	push	r22
 540:	7f 93       	push	r23
 542:	8f 93       	push	r24
 544:	9f 93       	push	r25
 546:	af 93       	push	r26
 548:	bf 93       	push	r27
 54a:	ef 93       	push	r30
 54c:	ff 93       	push	r31
 54e:	cf 93       	push	r28
 550:	df 93       	push	r29
 552:	cd b7       	in	r28, 0x3d	; 61
 554:	de b7       	in	r29, 0x3e	; 62
	schedule();
 556:	0e 94 4b 03 	call	0x696	; 0x696 <schedule>
}
 55a:	df 91       	pop	r29
 55c:	cf 91       	pop	r28
 55e:	ff 91       	pop	r31
 560:	ef 91       	pop	r30
 562:	bf 91       	pop	r27
 564:	af 91       	pop	r26
 566:	9f 91       	pop	r25
 568:	8f 91       	pop	r24
 56a:	7f 91       	pop	r23
 56c:	6f 91       	pop	r22
 56e:	5f 91       	pop	r21
 570:	4f 91       	pop	r20
 572:	3f 91       	pop	r19
 574:	2f 91       	pop	r18
 576:	0f 90       	pop	r0
 578:	00 92 5f 00 	sts	0x005F, r0
 57c:	0f 90       	pop	r0
 57e:	1f 90       	pop	r1
 580:	18 95       	reti

00000582 <setupTimer>:

/**
* Setup atmega32's clock for interrupts every 1ms
*/
void setupTimer(){
 582:	cf 93       	push	r28
 584:	df 93       	push	r29
 586:	cd b7       	in	r28, 0x3d	; 61
 588:	de b7       	in	r29, 0x3e	; 62

	TCCR0 |= (1<<WGM01) | (0<<WGM00);	// set clock type as CTC
 58a:	83 e5       	ldi	r24, 0x53	; 83
 58c:	90 e0       	ldi	r25, 0x00	; 0
 58e:	23 e5       	ldi	r18, 0x53	; 83
 590:	30 e0       	ldi	r19, 0x00	; 0
 592:	f9 01       	movw	r30, r18
 594:	20 81       	ld	r18, Z
 596:	28 60       	ori	r18, 0x08	; 8
 598:	fc 01       	movw	r30, r24
 59a:	20 83       	st	Z, r18
	OCR0 = 250;							// set Output Compare Register - together with prescaler this will give us
 59c:	8c e5       	ldi	r24, 0x5C	; 92
 59e:	90 e0       	ldi	r25, 0x00	; 0
 5a0:	2a ef       	ldi	r18, 0xFA	; 250
 5a2:	fc 01       	movw	r30, r24
 5a4:	20 83       	st	Z, r18
	// interrupt every 1ms
	sei();								// turn interrupts on
 5a6:	78 94       	sei
	TIMSK |= (1<<OCIE0);				// set interrupts co compare
 5a8:	89 e5       	ldi	r24, 0x59	; 89
 5aa:	90 e0       	ldi	r25, 0x00	; 0
 5ac:	29 e5       	ldi	r18, 0x59	; 89
 5ae:	30 e0       	ldi	r19, 0x00	; 0
 5b0:	f9 01       	movw	r30, r18
 5b2:	20 81       	ld	r18, Z
 5b4:	22 60       	ori	r18, 0x02	; 2
 5b6:	fc 01       	movw	r30, r24
 5b8:	20 83       	st	Z, r18
	TCCR0 |= (1<<CS00) | (1<<CS01 );	// set clock prescaler at 64*250 = 16,000; 16MHz * 16,000 = 1KHZ;
 5ba:	83 e5       	ldi	r24, 0x53	; 83
 5bc:	90 e0       	ldi	r25, 0x00	; 0
 5be:	23 e5       	ldi	r18, 0x53	; 83
 5c0:	30 e0       	ldi	r19, 0x00	; 0
 5c2:	f9 01       	movw	r30, r18
 5c4:	20 81       	ld	r18, Z
 5c6:	23 60       	ori	r18, 0x03	; 3
 5c8:	fc 01       	movw	r30, r24
 5ca:	20 83       	st	Z, r18

}
 5cc:	df 91       	pop	r29
 5ce:	cf 91       	pop	r28
 5d0:	08 95       	ret

000005d2 <changeDisplayingFunction>:
typedef void (*toSetupFunction)(void*); //pointer to function typed as changeThisTask from taskManager.h

/**
* This function is called from clock function when time reaches 1000sek and it's needed to turn off dot after seconds value. This function calls calls function changeThisTask from taskManager.h with argument change_display_above_1000_sek from clockDisplay.h, which changes function executing every 4ms from changeDisplayUnder1000sek to changeDisplayAbove1000sek.
*/
void changeDisplayingFunction(void* args){
 5d2:	cf 93       	push	r28
 5d4:	df 93       	push	r29
 5d6:	cd b7       	in	r28, 0x3d	; 61
 5d8:	de b7       	in	r29, 0x3e	; 62
 5da:	28 97       	sbiw	r28, 0x08	; 8
 5dc:	0f b6       	in	r0, 0x3f	; 63
 5de:	f8 94       	cli
 5e0:	de bf       	out	0x3e, r29	; 62
 5e2:	0f be       	out	0x3f, r0	; 63
 5e4:	cd bf       	out	0x3d, r28	; 61
 5e6:	98 87       	std	Y+8, r25	; 0x08
 5e8:	8f 83       	std	Y+7, r24	; 0x07
	toCallFunction foo = *((toCallFunction*) args);
 5ea:	8f 81       	ldd	r24, Y+7	; 0x07
 5ec:	98 85       	ldd	r25, Y+8	; 0x08
 5ee:	fc 01       	movw	r30, r24
 5f0:	80 81       	ld	r24, Z
 5f2:	91 81       	ldd	r25, Z+1	; 0x01
 5f4:	9a 83       	std	Y+2, r25	; 0x02
 5f6:	89 83       	std	Y+1, r24	; 0x01
	toSetupFunction fooSet = *((toSetupFunction*)(args + sizeof(toCallFunction)));
 5f8:	8f 81       	ldd	r24, Y+7	; 0x07
 5fa:	98 85       	ldd	r25, Y+8	; 0x08
 5fc:	fc 01       	movw	r30, r24
 5fe:	82 81       	ldd	r24, Z+2	; 0x02
 600:	93 81       	ldd	r25, Z+3	; 0x03
 602:	9c 83       	std	Y+4, r25	; 0x04
 604:	8b 83       	std	Y+3, r24	; 0x03
	void* argsSet = (void*)0;
 606:	1e 82       	std	Y+6, r1	; 0x06
 608:	1d 82       	std	Y+5, r1	; 0x05
	foo(fooSet, argsSet);
 60a:	4d 81       	ldd	r20, Y+5	; 0x05
 60c:	5e 81       	ldd	r21, Y+6	; 0x06
 60e:	8b 81       	ldd	r24, Y+3	; 0x03
 610:	9c 81       	ldd	r25, Y+4	; 0x04
 612:	29 81       	ldd	r18, Y+1	; 0x01
 614:	3a 81       	ldd	r19, Y+2	; 0x02
 616:	ba 01       	movw	r22, r20
 618:	f9 01       	movw	r30, r18
 61a:	09 95       	icall
}
 61c:	28 96       	adiw	r28, 0x08	; 8
 61e:	0f b6       	in	r0, 0x3f	; 63
 620:	f8 94       	cli
 622:	de bf       	out	0x3e, r29	; 62
 624:	0f be       	out	0x3f, r0	; 63
 626:	cd bf       	out	0x3d, r28	; 61
 628:	df 91       	pop	r29
 62a:	cf 91       	pop	r28
 62c:	08 95       	ret

0000062e <main>:

int main(void)
{
 62e:	cf 93       	push	r28
 630:	df 93       	push	r29
 632:	00 d0       	rcall	.+0      	; 0x634 <main+0x6>
 634:	00 d0       	rcall	.+0      	; 0x636 <main+0x8>
 636:	cd b7       	in	r28, 0x3d	; 61
 638:	de b7       	in	r29, 0x3e	; 62
	setupTimer();
 63a:	0e 94 c1 02 	call	0x582	; 0x582 <setupTimer>
	setupClockDisplay();
 63e:	0e 94 49 00 	call	0x92	; 0x92 <setupClockDisplay>
	void* argsChangingFunction[] = {changeThisTask, changeDisplayAbove1000sek};
 642:	87 e1       	ldi	r24, 0x17	; 23
 644:	94 e0       	ldi	r25, 0x04	; 4
 646:	9a 83       	std	Y+2, r25	; 0x02
 648:	89 83       	std	Y+1, r24	; 0x01
 64a:	86 ea       	ldi	r24, 0xA6	; 166
 64c:	90 e0       	ldi	r25, 0x00	; 0
 64e:	9c 83       	std	Y+4, r25	; 0x04
 650:	8b 83       	std	Y+3, r24	; 0x03
	setupFunctionToCallWhen1000(changeDisplayingFunction, (void*)argsChangingFunction);
 652:	ce 01       	movw	r24, r28
 654:	01 96       	adiw	r24, 0x01	; 1
 656:	bc 01       	movw	r22, r24
 658:	89 ee       	ldi	r24, 0xE9	; 233
 65a:	92 e0       	ldi	r25, 0x02	; 2
 65c:	0e 94 89 00 	call	0x112	; 0x112 <setupFunctionToCallWhen1000>
	addTask(0, 100, increment_value, (void*)0);
 660:	20 e0       	ldi	r18, 0x00	; 0
 662:	30 e0       	ldi	r19, 0x00	; 0
 664:	4a e6       	ldi	r20, 0x6A	; 106
 666:	50 e0       	ldi	r21, 0x00	; 0
 668:	64 e6       	ldi	r22, 0x64	; 100
 66a:	80 e0       	ldi	r24, 0x00	; 0
 66c:	0e 94 b9 03 	call	0x772	; 0x772 <addTask>
	addTask(1, 4, changeDisplayUnder1000sek, (void*)0);
 670:	20 e0       	ldi	r18, 0x00	; 0
 672:	30 e0       	ldi	r19, 0x00	; 0
 674:	42 e9       	ldi	r20, 0x92	; 146
 676:	51 e0       	ldi	r21, 0x01	; 1
 678:	64 e0       	ldi	r22, 0x04	; 4
 67a:	81 e0       	ldi	r24, 0x01	; 1
 67c:	0e 94 b9 03 	call	0x772	; 0x772 <addTask>
	execute();
 680:	0e 94 59 04 	call	0x8b2	; 0x8b2 <execute>
 684:	80 e0       	ldi	r24, 0x00	; 0
 686:	90 e0       	ldi	r25, 0x00	; 0
 688:	0f 90       	pop	r0
 68a:	0f 90       	pop	r0
 68c:	0f 90       	pop	r0
 68e:	0f 90       	pop	r0
 690:	df 91       	pop	r29
 692:	cf 91       	pop	r28
 694:	08 95       	ret

00000696 <schedule>:
} task;

volatile static int tasksToDo = 0;
volatile static task tasks[MAX_NUMBER_OF_TASKS];

void schedule(){
 696:	cf 93       	push	r28
 698:	df 93       	push	r29
 69a:	00 d0       	rcall	.+0      	; 0x69c <schedule+0x6>
 69c:	00 d0       	rcall	.+0      	; 0x69e <schedule+0x8>
 69e:	cd b7       	in	r28, 0x3d	; 61
 6a0:	de b7       	in	r29, 0x3e	; 62

	for (int i=0; i<MAX_NUMBER_OF_TASKS; i++){					// checking and incrementing loop
 6a2:	1a 82       	std	Y+2, r1	; 0x02
 6a4:	19 82       	std	Y+1, r1	; 0x01
 6a6:	58 c0       	rjmp	.+176    	; 0x758 <schedule+0xc2>
		tasks[i].counter++;											// time passes, increase every task's counter
 6a8:	29 81       	ldd	r18, Y+1	; 0x01
 6aa:	3a 81       	ldd	r19, Y+2	; 0x02
 6ac:	c9 01       	movw	r24, r18
 6ae:	88 0f       	add	r24, r24
 6b0:	99 1f       	adc	r25, r25
 6b2:	88 0f       	add	r24, r24
 6b4:	99 1f       	adc	r25, r25
 6b6:	88 0f       	add	r24, r24
 6b8:	99 1f       	adc	r25, r25
 6ba:	82 1b       	sub	r24, r18
 6bc:	93 0b       	sbc	r25, r19
 6be:	84 58       	subi	r24, 0x84	; 132
 6c0:	9f 4f       	sbci	r25, 0xFF	; 255
 6c2:	fc 01       	movw	r30, r24
 6c4:	80 81       	ld	r24, Z
 6c6:	91 81       	ldd	r25, Z+1	; 0x01
 6c8:	ac 01       	movw	r20, r24
 6ca:	4f 5f       	subi	r20, 0xFF	; 255
 6cc:	5f 4f       	sbci	r21, 0xFF	; 255
 6ce:	29 81       	ldd	r18, Y+1	; 0x01
 6d0:	3a 81       	ldd	r19, Y+2	; 0x02
 6d2:	c9 01       	movw	r24, r18
 6d4:	88 0f       	add	r24, r24
 6d6:	99 1f       	adc	r25, r25
 6d8:	88 0f       	add	r24, r24
 6da:	99 1f       	adc	r25, r25
 6dc:	88 0f       	add	r24, r24
 6de:	99 1f       	adc	r25, r25
 6e0:	82 1b       	sub	r24, r18
 6e2:	93 0b       	sbc	r25, r19
 6e4:	84 58       	subi	r24, 0x84	; 132
 6e6:	9f 4f       	sbci	r25, 0xFF	; 255
 6e8:	fc 01       	movw	r30, r24
 6ea:	51 83       	std	Z+1, r21	; 0x01
 6ec:	40 83       	st	Z, r20
		if (tasks[i].counter % tasks[i].interval == 0) tasksToDo++;	// check if one of the functions need to be executed now
 6ee:	29 81       	ldd	r18, Y+1	; 0x01
 6f0:	3a 81       	ldd	r19, Y+2	; 0x02
 6f2:	c9 01       	movw	r24, r18
 6f4:	88 0f       	add	r24, r24
 6f6:	99 1f       	adc	r25, r25
 6f8:	88 0f       	add	r24, r24
 6fa:	99 1f       	adc	r25, r25
 6fc:	88 0f       	add	r24, r24
 6fe:	99 1f       	adc	r25, r25
 700:	82 1b       	sub	r24, r18
 702:	93 0b       	sbc	r25, r19
 704:	84 58       	subi	r24, 0x84	; 132
 706:	9f 4f       	sbci	r25, 0xFF	; 255
 708:	fc 01       	movw	r30, r24
 70a:	40 81       	ld	r20, Z
 70c:	51 81       	ldd	r21, Z+1	; 0x01
 70e:	29 81       	ldd	r18, Y+1	; 0x01
 710:	3a 81       	ldd	r19, Y+2	; 0x02
 712:	c9 01       	movw	r24, r18
 714:	88 0f       	add	r24, r24
 716:	99 1f       	adc	r25, r25
 718:	88 0f       	add	r24, r24
 71a:	99 1f       	adc	r25, r25
 71c:	88 0f       	add	r24, r24
 71e:	99 1f       	adc	r25, r25
 720:	82 1b       	sub	r24, r18
 722:	93 0b       	sbc	r25, r19
 724:	85 58       	subi	r24, 0x85	; 133
 726:	9f 4f       	sbci	r25, 0xFF	; 255
 728:	fc 01       	movw	r30, r24
 72a:	80 81       	ld	r24, Z
 72c:	28 2f       	mov	r18, r24
 72e:	30 e0       	ldi	r19, 0x00	; 0
 730:	ca 01       	movw	r24, r20
 732:	b9 01       	movw	r22, r18
 734:	0e 94 1b 05 	call	0xa36	; 0xa36 <__udivmodhi4>
 738:	00 97       	sbiw	r24, 0x00	; 0
 73a:	49 f4       	brne	.+18     	; 0x74e <schedule+0xb8>
 73c:	80 91 75 00 	lds	r24, 0x0075
 740:	90 91 76 00 	lds	r25, 0x0076
 744:	01 96       	adiw	r24, 0x01	; 1
 746:	90 93 76 00 	sts	0x0076, r25
 74a:	80 93 75 00 	sts	0x0075, r24
volatile static int tasksToDo = 0;
volatile static task tasks[MAX_NUMBER_OF_TASKS];

void schedule(){

	for (int i=0; i<MAX_NUMBER_OF_TASKS; i++){					// checking and incrementing loop
 74e:	89 81       	ldd	r24, Y+1	; 0x01
 750:	9a 81       	ldd	r25, Y+2	; 0x02
 752:	01 96       	adiw	r24, 0x01	; 1
 754:	9a 83       	std	Y+2, r25	; 0x02
 756:	89 83       	std	Y+1, r24	; 0x01
 758:	89 81       	ldd	r24, Y+1	; 0x01
 75a:	9a 81       	ldd	r25, Y+2	; 0x02
 75c:	88 30       	cpi	r24, 0x08	; 8
 75e:	91 05       	cpc	r25, r1
 760:	0c f4       	brge	.+2      	; 0x764 <schedule+0xce>
 762:	a2 cf       	rjmp	.-188    	; 0x6a8 <schedule+0x12>
		tasks[i].counter++;											// time passes, increase every task's counter
		if (tasks[i].counter % tasks[i].interval == 0) tasksToDo++;	// check if one of the functions need to be executed now
	}

}
 764:	0f 90       	pop	r0
 766:	0f 90       	pop	r0
 768:	0f 90       	pop	r0
 76a:	0f 90       	pop	r0
 76c:	df 91       	pop	r29
 76e:	cf 91       	pop	r28
 770:	08 95       	ret

00000772 <addTask>:

void addTask(uint8_t numberOfTask, uint8_t interval, void (*foo)(void*), void* args){
 772:	cf 93       	push	r28
 774:	df 93       	push	r29
 776:	00 d0       	rcall	.+0      	; 0x778 <addTask+0x6>
 778:	00 d0       	rcall	.+0      	; 0x77a <addTask+0x8>
 77a:	00 d0       	rcall	.+0      	; 0x77c <addTask+0xa>
 77c:	cd b7       	in	r28, 0x3d	; 61
 77e:	de b7       	in	r29, 0x3e	; 62
 780:	89 83       	std	Y+1, r24	; 0x01
 782:	6a 83       	std	Y+2, r22	; 0x02
 784:	5c 83       	std	Y+4, r21	; 0x04
 786:	4b 83       	std	Y+3, r20	; 0x03
 788:	3e 83       	std	Y+6, r19	; 0x06
 78a:	2d 83       	std	Y+5, r18	; 0x05

	tasks[numberOfTask].foo = foo;
 78c:	89 81       	ldd	r24, Y+1	; 0x01
 78e:	28 2f       	mov	r18, r24
 790:	30 e0       	ldi	r19, 0x00	; 0
 792:	c9 01       	movw	r24, r18
 794:	88 0f       	add	r24, r24
 796:	99 1f       	adc	r25, r25
 798:	88 0f       	add	r24, r24
 79a:	99 1f       	adc	r25, r25
 79c:	88 0f       	add	r24, r24
 79e:	99 1f       	adc	r25, r25
 7a0:	82 1b       	sub	r24, r18
 7a2:	93 0b       	sbc	r25, r19
 7a4:	89 58       	subi	r24, 0x89	; 137
 7a6:	9f 4f       	sbci	r25, 0xFF	; 255
 7a8:	2b 81       	ldd	r18, Y+3	; 0x03
 7aa:	3c 81       	ldd	r19, Y+4	; 0x04
 7ac:	fc 01       	movw	r30, r24
 7ae:	31 83       	std	Z+1, r19	; 0x01
 7b0:	20 83       	st	Z, r18
	tasks[numberOfTask].args = args;
 7b2:	89 81       	ldd	r24, Y+1	; 0x01
 7b4:	28 2f       	mov	r18, r24
 7b6:	30 e0       	ldi	r19, 0x00	; 0
 7b8:	c9 01       	movw	r24, r18
 7ba:	88 0f       	add	r24, r24
 7bc:	99 1f       	adc	r25, r25
 7be:	88 0f       	add	r24, r24
 7c0:	99 1f       	adc	r25, r25
 7c2:	88 0f       	add	r24, r24
 7c4:	99 1f       	adc	r25, r25
 7c6:	82 1b       	sub	r24, r18
 7c8:	93 0b       	sbc	r25, r19
 7ca:	87 58       	subi	r24, 0x87	; 135
 7cc:	9f 4f       	sbci	r25, 0xFF	; 255
 7ce:	2d 81       	ldd	r18, Y+5	; 0x05
 7d0:	3e 81       	ldd	r19, Y+6	; 0x06
 7d2:	fc 01       	movw	r30, r24
 7d4:	31 83       	std	Z+1, r19	; 0x01
 7d6:	20 83       	st	Z, r18
	tasks[numberOfTask].interval = interval;
 7d8:	89 81       	ldd	r24, Y+1	; 0x01
 7da:	28 2f       	mov	r18, r24
 7dc:	30 e0       	ldi	r19, 0x00	; 0
 7de:	c9 01       	movw	r24, r18
 7e0:	88 0f       	add	r24, r24
 7e2:	99 1f       	adc	r25, r25
 7e4:	88 0f       	add	r24, r24
 7e6:	99 1f       	adc	r25, r25
 7e8:	88 0f       	add	r24, r24
 7ea:	99 1f       	adc	r25, r25
 7ec:	82 1b       	sub	r24, r18
 7ee:	93 0b       	sbc	r25, r19
 7f0:	85 58       	subi	r24, 0x85	; 133
 7f2:	9f 4f       	sbci	r25, 0xFF	; 255
 7f4:	2a 81       	ldd	r18, Y+2	; 0x02
 7f6:	fc 01       	movw	r30, r24
 7f8:	20 83       	st	Z, r18
	tasks[numberOfTask].counter = 0;
 7fa:	89 81       	ldd	r24, Y+1	; 0x01
 7fc:	28 2f       	mov	r18, r24
 7fe:	30 e0       	ldi	r19, 0x00	; 0
 800:	c9 01       	movw	r24, r18
 802:	88 0f       	add	r24, r24
 804:	99 1f       	adc	r25, r25
 806:	88 0f       	add	r24, r24
 808:	99 1f       	adc	r25, r25
 80a:	88 0f       	add	r24, r24
 80c:	99 1f       	adc	r25, r25
 80e:	82 1b       	sub	r24, r18
 810:	93 0b       	sbc	r25, r19
 812:	84 58       	subi	r24, 0x84	; 132
 814:	9f 4f       	sbci	r25, 0xFF	; 255
 816:	fc 01       	movw	r30, r24
 818:	11 82       	std	Z+1, r1	; 0x01
 81a:	10 82       	st	Z, r1

}
 81c:	26 96       	adiw	r28, 0x06	; 6
 81e:	0f b6       	in	r0, 0x3f	; 63
 820:	f8 94       	cli
 822:	de bf       	out	0x3e, r29	; 62
 824:	0f be       	out	0x3f, r0	; 63
 826:	cd bf       	out	0x3d, r28	; 61
 828:	df 91       	pop	r29
 82a:	cf 91       	pop	r28
 82c:	08 95       	ret

0000082e <changeThisTask>:
void deleteThisTask(){
	if (currentTaskToDo == -1) return;
	tasks[currentTaskToDo].interval = 0;
}

void changeThisTask(void (*foo)(void*), void* args){
 82e:	cf 93       	push	r28
 830:	df 93       	push	r29
 832:	00 d0       	rcall	.+0      	; 0x834 <changeThisTask+0x6>
 834:	00 d0       	rcall	.+0      	; 0x836 <changeThisTask+0x8>
 836:	cd b7       	in	r28, 0x3d	; 61
 838:	de b7       	in	r29, 0x3e	; 62
 83a:	9a 83       	std	Y+2, r25	; 0x02
 83c:	89 83       	std	Y+1, r24	; 0x01
 83e:	7c 83       	std	Y+4, r23	; 0x04
 840:	6b 83       	std	Y+3, r22	; 0x03
	if (currentTaskToDo == -1) return;
 842:	80 91 6b 00 	lds	r24, 0x006B
 846:	8f 3f       	cpi	r24, 0xFF	; 255
 848:	09 f4       	brne	.+2      	; 0x84c <changeThisTask+0x1e>
 84a:	2c c0       	rjmp	.+88     	; 0x8a4 <__stack+0x45>
	tasks[currentTaskToDo].foo = foo;
 84c:	80 91 6b 00 	lds	r24, 0x006B
 850:	28 2f       	mov	r18, r24
 852:	33 27       	eor	r19, r19
 854:	27 fd       	sbrc	r18, 7
 856:	30 95       	com	r19
 858:	c9 01       	movw	r24, r18
 85a:	88 0f       	add	r24, r24
 85c:	99 1f       	adc	r25, r25
 85e:	88 0f       	add	r24, r24
 860:	99 1f       	adc	r25, r25
 862:	88 0f       	add	r24, r24
 864:	99 1f       	adc	r25, r25
 866:	82 1b       	sub	r24, r18
 868:	93 0b       	sbc	r25, r19
 86a:	89 58       	subi	r24, 0x89	; 137
 86c:	9f 4f       	sbci	r25, 0xFF	; 255
 86e:	29 81       	ldd	r18, Y+1	; 0x01
 870:	3a 81       	ldd	r19, Y+2	; 0x02
 872:	fc 01       	movw	r30, r24
 874:	31 83       	std	Z+1, r19	; 0x01
 876:	20 83       	st	Z, r18
	tasks[currentTaskToDo].args = args;
 878:	80 91 6b 00 	lds	r24, 0x006B
 87c:	28 2f       	mov	r18, r24
 87e:	33 27       	eor	r19, r19
 880:	27 fd       	sbrc	r18, 7
 882:	30 95       	com	r19
 884:	c9 01       	movw	r24, r18
 886:	88 0f       	add	r24, r24
 888:	99 1f       	adc	r25, r25
 88a:	88 0f       	add	r24, r24
 88c:	99 1f       	adc	r25, r25
 88e:	88 0f       	add	r24, r24
 890:	99 1f       	adc	r25, r25
 892:	82 1b       	sub	r24, r18
 894:	93 0b       	sbc	r25, r19
 896:	87 58       	subi	r24, 0x87	; 135
 898:	9f 4f       	sbci	r25, 0xFF	; 255
 89a:	2b 81       	ldd	r18, Y+3	; 0x03
 89c:	3c 81       	ldd	r19, Y+4	; 0x04
 89e:	fc 01       	movw	r30, r24
 8a0:	31 83       	std	Z+1, r19	; 0x01
 8a2:	20 83       	st	Z, r18
}
 8a4:	0f 90       	pop	r0
 8a6:	0f 90       	pop	r0
 8a8:	0f 90       	pop	r0
 8aa:	0f 90       	pop	r0
 8ac:	df 91       	pop	r29
 8ae:	cf 91       	pop	r28
 8b0:	08 95       	ret

000008b2 <execute>:
void changeTask(uint8_t numberOfTask, void (*foo)(void*), void* args){
	tasks[numberOfTask].foo = foo;
	tasks[numberOfTask].args = args;
}

void execute(){
 8b2:	cf 93       	push	r28
 8b4:	df 93       	push	r29
 8b6:	00 d0       	rcall	.+0      	; 0x8b8 <execute+0x6>
 8b8:	cd b7       	in	r28, 0x3d	; 61
 8ba:	de b7       	in	r29, 0x3e	; 62

	while (1){

		while (tasksToDo == 0){}	  // empty loop for idling (when ther;'s no task to do)
 8bc:	00 00       	nop
 8be:	80 91 75 00 	lds	r24, 0x0075
 8c2:	90 91 76 00 	lds	r25, 0x0076
 8c6:	00 97       	sbiw	r24, 0x00	; 0
 8c8:	d1 f3       	breq	.-12     	; 0x8be <execute+0xc>
		cli();						  // turn interrupts off, for synchronicity's sake
 8ca:	f8 94       	cli

		for (int i=0; i<MAX_NUMBER_OF_TASKS; i++)								// checking loop
 8cc:	1a 82       	std	Y+2, r1	; 0x02
 8ce:	19 82       	std	Y+1, r1	; 0x01
 8d0:	7c c0       	rjmp	.+248    	; 0x9ca <execute+0x118>
		{
			if ( tasks[i].interval > 0 && tasks[i].counter >= tasks[i].interval )	// check if there's a task to execute
 8d2:	29 81       	ldd	r18, Y+1	; 0x01
 8d4:	3a 81       	ldd	r19, Y+2	; 0x02
 8d6:	c9 01       	movw	r24, r18
 8d8:	88 0f       	add	r24, r24
 8da:	99 1f       	adc	r25, r25
 8dc:	88 0f       	add	r24, r24
 8de:	99 1f       	adc	r25, r25
 8e0:	88 0f       	add	r24, r24
 8e2:	99 1f       	adc	r25, r25
 8e4:	82 1b       	sub	r24, r18
 8e6:	93 0b       	sbc	r25, r19
 8e8:	85 58       	subi	r24, 0x85	; 133
 8ea:	9f 4f       	sbci	r25, 0xFF	; 255
 8ec:	fc 01       	movw	r30, r24
 8ee:	80 81       	ld	r24, Z
 8f0:	88 23       	and	r24, r24
 8f2:	09 f4       	brne	.+2      	; 0x8f6 <execute+0x44>
 8f4:	65 c0       	rjmp	.+202    	; 0x9c0 <execute+0x10e>
 8f6:	29 81       	ldd	r18, Y+1	; 0x01
 8f8:	3a 81       	ldd	r19, Y+2	; 0x02
 8fa:	c9 01       	movw	r24, r18
 8fc:	88 0f       	add	r24, r24
 8fe:	99 1f       	adc	r25, r25
 900:	88 0f       	add	r24, r24
 902:	99 1f       	adc	r25, r25
 904:	88 0f       	add	r24, r24
 906:	99 1f       	adc	r25, r25
 908:	82 1b       	sub	r24, r18
 90a:	93 0b       	sbc	r25, r19
 90c:	84 58       	subi	r24, 0x84	; 132
 90e:	9f 4f       	sbci	r25, 0xFF	; 255
 910:	fc 01       	movw	r30, r24
 912:	40 81       	ld	r20, Z
 914:	51 81       	ldd	r21, Z+1	; 0x01
 916:	29 81       	ldd	r18, Y+1	; 0x01
 918:	3a 81       	ldd	r19, Y+2	; 0x02
 91a:	c9 01       	movw	r24, r18
 91c:	88 0f       	add	r24, r24
 91e:	99 1f       	adc	r25, r25
 920:	88 0f       	add	r24, r24
 922:	99 1f       	adc	r25, r25
 924:	88 0f       	add	r24, r24
 926:	99 1f       	adc	r25, r25
 928:	82 1b       	sub	r24, r18
 92a:	93 0b       	sbc	r25, r19
 92c:	85 58       	subi	r24, 0x85	; 133
 92e:	9f 4f       	sbci	r25, 0xFF	; 255
 930:	fc 01       	movw	r30, r24
 932:	80 81       	ld	r24, Z
 934:	88 2f       	mov	r24, r24
 936:	90 e0       	ldi	r25, 0x00	; 0
 938:	48 17       	cp	r20, r24
 93a:	59 07       	cpc	r21, r25
 93c:	08 f4       	brcc	.+2      	; 0x940 <execute+0x8e>
 93e:	40 c0       	rjmp	.+128    	; 0x9c0 <execute+0x10e>
			{																		// if there is...
				tasks[i].counter -= tasks[i].interval;									// decrease its counter by its interval (1 execution)
 940:	29 81       	ldd	r18, Y+1	; 0x01
 942:	3a 81       	ldd	r19, Y+2	; 0x02
 944:	c9 01       	movw	r24, r18
 946:	88 0f       	add	r24, r24
 948:	99 1f       	adc	r25, r25
 94a:	88 0f       	add	r24, r24
 94c:	99 1f       	adc	r25, r25
 94e:	88 0f       	add	r24, r24
 950:	99 1f       	adc	r25, r25
 952:	82 1b       	sub	r24, r18
 954:	93 0b       	sbc	r25, r19
 956:	84 58       	subi	r24, 0x84	; 132
 958:	9f 4f       	sbci	r25, 0xFF	; 255
 95a:	fc 01       	movw	r30, r24
 95c:	40 81       	ld	r20, Z
 95e:	51 81       	ldd	r21, Z+1	; 0x01
 960:	29 81       	ldd	r18, Y+1	; 0x01
 962:	3a 81       	ldd	r19, Y+2	; 0x02
 964:	c9 01       	movw	r24, r18
 966:	88 0f       	add	r24, r24
 968:	99 1f       	adc	r25, r25
 96a:	88 0f       	add	r24, r24
 96c:	99 1f       	adc	r25, r25
 96e:	88 0f       	add	r24, r24
 970:	99 1f       	adc	r25, r25
 972:	82 1b       	sub	r24, r18
 974:	93 0b       	sbc	r25, r19
 976:	85 58       	subi	r24, 0x85	; 133
 978:	9f 4f       	sbci	r25, 0xFF	; 255
 97a:	fc 01       	movw	r30, r24
 97c:	80 81       	ld	r24, Z
 97e:	88 2f       	mov	r24, r24
 980:	90 e0       	ldi	r25, 0x00	; 0
 982:	48 1b       	sub	r20, r24
 984:	59 0b       	sbc	r21, r25
 986:	29 81       	ldd	r18, Y+1	; 0x01
 988:	3a 81       	ldd	r19, Y+2	; 0x02
 98a:	c9 01       	movw	r24, r18
 98c:	88 0f       	add	r24, r24
 98e:	99 1f       	adc	r25, r25
 990:	88 0f       	add	r24, r24
 992:	99 1f       	adc	r25, r25
 994:	88 0f       	add	r24, r24
 996:	99 1f       	adc	r25, r25
 998:	82 1b       	sub	r24, r18
 99a:	93 0b       	sbc	r25, r19
 99c:	84 58       	subi	r24, 0x84	; 132
 99e:	9f 4f       	sbci	r25, 0xFF	; 255
 9a0:	fc 01       	movw	r30, r24
 9a2:	51 83       	std	Z+1, r21	; 0x01
 9a4:	40 83       	st	Z, r20
				currentTaskToDo = i;														// remember which task it was
 9a6:	89 81       	ldd	r24, Y+1	; 0x01
 9a8:	80 93 6b 00 	sts	0x006B, r24
				tasksToDo--;															// decrease number of task that still need executing
 9ac:	80 91 75 00 	lds	r24, 0x0075
 9b0:	90 91 76 00 	lds	r25, 0x0076
 9b4:	01 97       	sbiw	r24, 0x01	; 1
 9b6:	90 93 76 00 	sts	0x0076, r25
 9ba:	80 93 75 00 	sts	0x0075, r24
				break;																	// finally, leave the loop for imminent execution
 9be:	0b c0       	rjmp	.+22     	; 0x9d6 <execute+0x124>
	while (1){

		while (tasksToDo == 0){}	  // empty loop for idling (when ther;'s no task to do)
		cli();						  // turn interrupts off, for synchronicity's sake

		for (int i=0; i<MAX_NUMBER_OF_TASKS; i++)								// checking loop
 9c0:	89 81       	ldd	r24, Y+1	; 0x01
 9c2:	9a 81       	ldd	r25, Y+2	; 0x02
 9c4:	01 96       	adiw	r24, 0x01	; 1
 9c6:	9a 83       	std	Y+2, r25	; 0x02
 9c8:	89 83       	std	Y+1, r24	; 0x01
 9ca:	89 81       	ldd	r24, Y+1	; 0x01
 9cc:	9a 81       	ldd	r25, Y+2	; 0x02
 9ce:	88 30       	cpi	r24, 0x08	; 8
 9d0:	91 05       	cpc	r25, r1
 9d2:	0c f4       	brge	.+2      	; 0x9d6 <execute+0x124>
 9d4:	7e cf       	rjmp	.-260    	; 0x8d2 <execute+0x20>
				tasksToDo--;															// decrease number of task that still need executing
				break;																	// finally, leave the loop for imminent execution
			}
		}

		sei();												// turn interrupts on again
 9d6:	78 94       	sei
		tasks[currentTaskToDo].foo(tasks[currentTaskToDo].args);	// execute the remembered task
 9d8:	80 91 6b 00 	lds	r24, 0x006B
 9dc:	28 2f       	mov	r18, r24
 9de:	33 27       	eor	r19, r19
 9e0:	27 fd       	sbrc	r18, 7
 9e2:	30 95       	com	r19
 9e4:	c9 01       	movw	r24, r18
 9e6:	88 0f       	add	r24, r24
 9e8:	99 1f       	adc	r25, r25
 9ea:	88 0f       	add	r24, r24
 9ec:	99 1f       	adc	r25, r25
 9ee:	88 0f       	add	r24, r24
 9f0:	99 1f       	adc	r25, r25
 9f2:	82 1b       	sub	r24, r18
 9f4:	93 0b       	sbc	r25, r19
 9f6:	89 58       	subi	r24, 0x89	; 137
 9f8:	9f 4f       	sbci	r25, 0xFF	; 255
 9fa:	fc 01       	movw	r30, r24
 9fc:	40 81       	ld	r20, Z
 9fe:	51 81       	ldd	r21, Z+1	; 0x01
 a00:	80 91 6b 00 	lds	r24, 0x006B
 a04:	28 2f       	mov	r18, r24
 a06:	33 27       	eor	r19, r19
 a08:	27 fd       	sbrc	r18, 7
 a0a:	30 95       	com	r19
 a0c:	c9 01       	movw	r24, r18
 a0e:	88 0f       	add	r24, r24
 a10:	99 1f       	adc	r25, r25
 a12:	88 0f       	add	r24, r24
 a14:	99 1f       	adc	r25, r25
 a16:	88 0f       	add	r24, r24
 a18:	99 1f       	adc	r25, r25
 a1a:	82 1b       	sub	r24, r18
 a1c:	93 0b       	sbc	r25, r19
 a1e:	87 58       	subi	r24, 0x87	; 135
 a20:	9f 4f       	sbci	r25, 0xFF	; 255
 a22:	fc 01       	movw	r30, r24
 a24:	80 81       	ld	r24, Z
 a26:	91 81       	ldd	r25, Z+1	; 0x01
 a28:	fa 01       	movw	r30, r20
 a2a:	09 95       	icall
		currentTaskToDo = -1;
 a2c:	8f ef       	ldi	r24, 0xFF	; 255
 a2e:	80 93 6b 00 	sts	0x006B, r24

	}
 a32:	00 00       	nop

void execute(){

	while (1){

		while (tasksToDo == 0){}	  // empty loop for idling (when ther;'s no task to do)
 a34:	43 cf       	rjmp	.-378    	; 0x8bc <execute+0xa>

00000a36 <__udivmodhi4>:
 a36:	aa 1b       	sub	r26, r26
 a38:	bb 1b       	sub	r27, r27
 a3a:	51 e1       	ldi	r21, 0x11	; 17
 a3c:	07 c0       	rjmp	.+14     	; 0xa4c <__udivmodhi4_ep>

00000a3e <__udivmodhi4_loop>:
 a3e:	aa 1f       	adc	r26, r26
 a40:	bb 1f       	adc	r27, r27
 a42:	a6 17       	cp	r26, r22
 a44:	b7 07       	cpc	r27, r23
 a46:	10 f0       	brcs	.+4      	; 0xa4c <__udivmodhi4_ep>
 a48:	a6 1b       	sub	r26, r22
 a4a:	b7 0b       	sbc	r27, r23

00000a4c <__udivmodhi4_ep>:
 a4c:	88 1f       	adc	r24, r24
 a4e:	99 1f       	adc	r25, r25
 a50:	5a 95       	dec	r21
 a52:	a9 f7       	brne	.-22     	; 0xa3e <__udivmodhi4_loop>
 a54:	80 95       	com	r24
 a56:	90 95       	com	r25
 a58:	bc 01       	movw	r22, r24
 a5a:	cd 01       	movw	r24, r26
 a5c:	08 95       	ret

00000a5e <__udivmodsi4>:
 a5e:	a1 e2       	ldi	r26, 0x21	; 33
 a60:	1a 2e       	mov	r1, r26
 a62:	aa 1b       	sub	r26, r26
 a64:	bb 1b       	sub	r27, r27
 a66:	fd 01       	movw	r30, r26
 a68:	0d c0       	rjmp	.+26     	; 0xa84 <__udivmodsi4_ep>

00000a6a <__udivmodsi4_loop>:
 a6a:	aa 1f       	adc	r26, r26
 a6c:	bb 1f       	adc	r27, r27
 a6e:	ee 1f       	adc	r30, r30
 a70:	ff 1f       	adc	r31, r31
 a72:	a2 17       	cp	r26, r18
 a74:	b3 07       	cpc	r27, r19
 a76:	e4 07       	cpc	r30, r20
 a78:	f5 07       	cpc	r31, r21
 a7a:	20 f0       	brcs	.+8      	; 0xa84 <__udivmodsi4_ep>
 a7c:	a2 1b       	sub	r26, r18
 a7e:	b3 0b       	sbc	r27, r19
 a80:	e4 0b       	sbc	r30, r20
 a82:	f5 0b       	sbc	r31, r21

00000a84 <__udivmodsi4_ep>:
 a84:	66 1f       	adc	r22, r22
 a86:	77 1f       	adc	r23, r23
 a88:	88 1f       	adc	r24, r24
 a8a:	99 1f       	adc	r25, r25
 a8c:	1a 94       	dec	r1
 a8e:	69 f7       	brne	.-38     	; 0xa6a <__udivmodsi4_loop>
 a90:	60 95       	com	r22
 a92:	70 95       	com	r23
 a94:	80 95       	com	r24
 a96:	90 95       	com	r25
 a98:	9b 01       	movw	r18, r22
 a9a:	ac 01       	movw	r20, r24
 a9c:	bd 01       	movw	r22, r26
 a9e:	cf 01       	movw	r24, r30
 aa0:	08 95       	ret

00000aa2 <_exit>:
 aa2:	f8 94       	cli

00000aa4 <__stop_program>:
 aa4:	ff cf       	rjmp	.-2      	; 0xaa4 <__stop_program>
